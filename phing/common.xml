<?xml version="1.0"?>
<!--
  ~ @package   buildfiles
  ~ @copyright Copyright (c)2010-2020 Nicholas K. Dionysopoulos / Akeeba Ltd
  ~ @license   GNU General Public License version 3, or later
  -->
<project name="common" basedir="." description="Common phing tasks for building Joomla! extensions"
         default="git">
    <!--
    You need to import this file in your main Phing file like this:

    <import file="${phing.dir}/../../buildfiles/phing/common.xml" />
    -->

    <!-- Built in properties -->
    <!-- ### Project Paths -->
    <property name="dirs.root" value="${phing.dir}/.." />
    <property name="dirs.release" value="${dirs.root}/release" />
    <!-- ### Software and Documentation Paths -->
    <property name="dirs.component" value="${dirs.root}/component" />
    <property name="dirs.modules" value="${dirs.root}/modules" />
    <property name="dirs.plugins" value="${dirs.root}/plugins" />
    <property name="dirs.documentation" value="${dirs.root}/documentation" />
    <property name="dirs.composer" value="${dirs.root}" />
    <property name="bin.composer" value="${dirs.root}/../buildfiles/composer.phar" />
    <!-- ### DocBook XML Stylesheet Paths -->
    <property name="dirs.bin" value="${phing.dir.common}/bin" />
    <property name="dirs.bin.libxml" value="${dirs.bin}/libxml" />
    <property name="dirs.bin.fop" value="${dirs.bin}/fop" />
    <property name="dirs.bin.dbxsl" value="${dirs.bin}/dbxsl" />
    <!-- ### Should I include FOF 3.x in the build? -->
	<property name="build.fof" value="1" />
    <!-- ### Should I include FOF 4.x in the build? -->
	<property name="build.fof4" value="0" />
	<!-- ### Should I include Akeeba Frontend Framework in the build? -->
	<property name="build.fef" value="0" />
	<!-- Initialize the site parameter for relink -->
	<property name="site" value="${build.relink_site}" />
	<property name="sitewp" value="${build.relink_sitewp}" />

    <!-- ### Version numbers -->
    <property name="version" value="git" />

    <!-- Load externally defined properties -->
    <!-- ### Default properties, located next to the common.xml file -->
    <property file="${phing.dir.common}/default.properties" />
    <!-- ### Common properties, stored one level above the repository's root -->
    <property file="${phing.dir}/../../build.properties" override="true" />
    <!-- ### Project properties -->
    <property file="${phing.dir}/build.properties" override="true" />
    <!-- ### Overrides, per project -->
    <property file="${phing.dir}/override.properties" override="true" />

    <!-- Custom task definitions -->
    <includepath classpath="${phing.dir.common}" />

    <taskdef name="gitdate" classname="tasks.GitDateTask" />
    <taskdef name="GitHubAsset" classname="tasks.GitHubAssetTask" />
    <taskdef name="GitHubRelease" classname="tasks.GitHubReleaseTask" />
    <taskdef name="gitversion" classname="tasks.GitVersionTask" />
    <taskdef name="jpa" classname="tasks.JPATask" />
    <taskdef name="link" classname="tasks.LinkTask" />
    <taskdef name="projectlink" classname="tasks.ProjectLinkTask" />
    <taskdef name="relinksite" classname="tasks.RelinkSiteTask" />
    <taskdef name="relinkwp" classname="tasks.RelinkWPSiteTask" />
    <taskdef name="zipme" classname="tasks.ZipmeTask" />
    <taskdef name="docbook2fo" classname="tasks.DocBookToFoTask" />
    <taskdef name="docbook2epub" classname="tasks.DocBookToEpubTask" />
	<!-- See https://github.com/rchouinard/phing-tasks/blob/master/classes/rych/tasks/YuiCompressorTask.php -->
    <taskdef name="yuicompressor" classname="tasks.YuiCompressorTask" />
    <taskdef name="closure" classname="tasks.ClosureTask" />
    <taskdef name="bladejoomla" classname="tasks.BladeJoomlaTask" />
    <taskdef name="bladeawf" classname="tasks.BladeAwfTask" />
    <taskdef name="curlsftp" classname="tasks.CurlSftpTask" />
	<taskdef name="svnadd" classname="tasks.SvnaddTask"/>
	<taskdef name="svnremove" classname="tasks.SvnremoveTask"/>
	<taskdef name="xmlversion" classname="tasks.XmlVersionTask"/>

	<!--
	Generate the installation packages and the documentation
	-->
	<target name="all" description="Makes everything"
			depends="git,documentation">
	</target>

	<!--
	Generate the installation packages. By default it generates a development build. You can pass a specific version
	number to make a numbered version release, e.g. `phing git -Dversion=1.2.3` to build version 1.2.3
	-->
	<target name="git" description="Makes only packages, not the documentation"
			depends="new-release,setup-properties,component-packages">
	</target>

    <!--
    Set up the basic version and build properties required to build files
    -->
    <target name="setup-properties" description="Set up version and build properties">
        <!-- Initialize the build.date timestamp -->
        <tstamp>
            <format property="build.date" pattern="%Y-%m-%d" />
        </tstamp>

        <!-- Initialize the version if it's not set -->
        <if>
            <equals arg1="${version}" arg2="git" />
            <then>
                <gitversion workingcopy="${dirs.root}" propertyname="git.lastrevision" />
                <property name="version" value="rev${git.lastrevision}" override="true" />
            </then>
        </if>
    </target>

    <!--
    Creates the release directory afresh before building anything

    This task depends on link and composer-install to make sure that you have a sane environment before you start
    building a package.
    -->
    <target name="new-release" description="Create afresh the release directory"
			depends="composer-install,link">
        <delete dir="${dirs.release}" quiet="true" includeemptydirs="true" />
        <mkdir dir="${dirs.release}" />
    </target>

    <!--
    Installs Composer dependencies.

    It's highly recommended that you commit your composer.lock in the repository. It makes sure that all build machines
    install the same version of the dependencies as your development machine.

    By default we look for composer.json in the repository root. If you have it elsewhere please update the
    dirs.composer property in your build.properties or build.xml file.
    -->
    <target name="composer-install">
        <if>
			<available file="${dirs.composer}/composer.json" type="file" />
			<then>
				<composer composer="${bin.composer}" command="install">
					<arg value="-d" />
					<arg path="${dirs.composer}" />
				</composer>
			</then>
		</if>
    </target>

    <!--
    Transforms a DocBook XML file to PDF format

    docs.input      DocBook XML filename relative to dirs.documentation
    -->
    <target name="docbook-pdf" description="Render documentation in PDF format">
        <basename property="docs.output" file="${docs.input}" suffix=".xml" />

		<if>
			<equals arg1="${docs.php_xsltproc}" arg2="1" />
			<then>
				<!-- Use the xsltproc included in your current PHP installation -->
				<docbook2fo xsltRoot="${dirs.bin.dbxsl}"
							docBookFile="${dirs.documentation}/${docs.input}"
							foFile="${dirs.release}/${docs.output}.fo"
				/>
			</then>
			<else>
				<!-- Use the xsltproc executable -->
				<exec executable="${docs.xsltproc}" dir="${dirs.documentation}" checkreturn="true">
					<arg value="--nonet" />
					<arg value="--xinclude" />
					<arg value="--novalid" />

					<arg value="--stringparam" />
					<arg value="body.start.indent" />
					<arg value="0" />

					<arg value="--stringparam" />
					<arg value="variablelist.term.break.after 1" />
					<arg value="1" />

					<arg value="--stringparam" />
					<arg value="variablelist.term.separator" />
					<arg value="&quot;&quot;" />

					<arg value="--stringparam" />
					<arg value="variablelist.max.termlength" />
					<arg value="12" />

					<arg value="--stringparam" />
					<arg value="section.autolabel" />
					<arg value="1" />

					<arg value="--stringparam" />
					<arg value="toc.section.depth" />
					<arg value="5" />

					<arg value="--stringparam" />
					<arg value="fop1.extensions" />
					<arg value="1" />

					<arg value="--output" />
					<arg file="${dirs.release}/${docs.output}.fo" />

					<arg file="${dirs.bin.dbxsl}/fo/docbook.xsl" />

					<arg file="${dirs.documentation}/${docs.input}" />
				</exec>
			</else>
		</if>

        <exec executable="${dirs.bin.fop}/fop" dir="${dirs.documentation}" checkreturn="true">
            <arg value="-fo" />
            <arg file="${dirs.release}/${docs.output}.fo" />

            <arg value="-pdf" />
            <arg file="${dirs.release}/${docs.output}.pdf" />
        </exec>

        <delete file="${dirs.release}/${docs.output}.fo" quiet="true" />
    </target>

    <!--
    Transforms a DocBook XML file to ePub format

    docs.input      DocBook XML filename relative to dirs.documentation
    -->
    <target name="docbook-epub" description="Render documentation in ePub format">
        <basename property="docs.output" file="${docs.input}" suffix=".xml" />
        <dirname property="docs.images" file="${dirs.documentation}/${docs.input}" />

        <property name="docs.epubdir" value="${dirs.release}/tmp_${docs.output}" />

        <mkdir dir="${docs.epubdir}" />
        <mkdir dir="${docs.epubdir}/OEBPS" />
        <mkdir dir="${docs.epubdir}/META-INF" />
        <mkdir dir="${docs.epubdir}/OEBPS/images" />
        <copy todir="${docs.epubdir}/OEBPS/images">
            <fileset dir="${docs.images}/images">
                <include name="*.png" />
                <include name="*.jpg" />
                <include name="*.jpeg" />
                <include name="*.gif" />
            </fileset>
        </copy>

		<if>
			<equals arg1="${docs.php_xsltproc}" arg2="1"/>
			<then>
				<!-- Use the xsltproc included in your current PHP installation -->
				<docbook2epub xsltRoot="${dirs.bin.dbxsl}"
							  docBookFile="${dirs.documentation}/${docs.input}"
							  epubPath="${docs.epubdir}"
				/>
			</then>
			<else>
				<exec executable="${docs.xsltproc}" dir="${dirs.documentation}" checkreturn="true">
					<arg value="--nonet" />
					<arg value="--xinclude" />
					<arg value="--novalid" />

					<arg value="--stringparam" />
					<arg value="epub.stylesheet" />
					<arg value="style.css" />

					<arg value="--stringparam" />
					<arg value="body.start.indent" />
					<arg value="0" />

					<arg value="--stringparam" />
					<arg value="variablelist.term.break.after 1" />
					<arg value="1" />

					<arg value="--stringparam" />
					<arg value="variablelist.term.separator" />
					<arg value="&quot;&quot;" />

					<arg value="--stringparam" />
					<arg value="variablelist.max.termlength" />
					<arg value="12" />

					<arg value="--stringparam" />
					<arg value="section.autolabel" />
					<arg value="1" />

					<arg value="--stringparam" />
					<arg value="toc.section.depth" />
					<arg value="5" />

					<arg value="--output" />
					<arg file="${docs.epubdir}/${docs.output}.epub" />

					<arg file="${dirs.bin.dbxsl}/epub3/chunk.xsl" />

					<arg file="${dirs.documentation}/${docs.input}" />
				</exec>
			</else>
		</if>

        <copy file="${phing.dir.common}/epub/mimetype" tofile="${docs.epubdir}/mimetype" overwrite="true" />
        <copy file="${phing.dir.common}/epub/com.apple.ibooks.display-options.xml" tofile="${docs.epubdir}/META-INF/com.apple.ibooks.display-options.xml" overwrite="true" />
        <copy file="${phing.dir.common}/epub/docbook-epub.css" tofile="${docs.epubdir}/OEBPS/docbook-epub.css" overwrite="true" />

        <zip destfile="${dirs.release}/${docs.output}.epub" basedir="${docs.epubdir}">
            <fileset dir="${docs.epubdir}">
                <include name="**" />
            </fileset>
        </zip>

        <delete dir="${docs.epubdir}" quiet="true" />
    </target>

    <!--
    Copy DocBook XML documentation to the remote server, for use by Akeeba DocImport³

    scp.dir.docs            Absolute SFTP path where documentation files are stored
    docsdeploy.path.source  Path to the documentation source, relative to ${dirs.documentation}
    docsdeploy.path.target  SFTP path to uploaded documentation, relative to ${scp.dir.docs}
    -->
    <target name="docbook-deploy" >
        <basename property="docsdeploy.name" file="${docsdeploy.path.source}" />
        <echo>Uploading ${docsdeploy.name}</echo>
        <curlsftp
                host="${scp.host}"
                port="${scp.port}"
                username="${scp.username}"
                password="${scp.password}"
                pubkeyfile="${scp.pubkeyfile}"
                privkeyfile="${scp.privkeyfile}"
                privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                todir="${scp.dir.docs}/${docsdeploy.path.target}"
                level="debug">
            <fileset dir="${dirs.documentation}/${docsdeploy.path.source}">
                <include name="*.xml"/>
                <include name="images/**"/>
                <include name="chapters/**"/>
            </fileset>
        </curlsftp>
    </target>

    <!--
    Uses Akeeba Release maker to deploy new releases to a remote Akeeba Release System installation.

    release.source              Absolute path and filename to the release.json prototype we're going to use
    release.api.endpoint        URL to the ARS API endpoint
    release.api.username        Username for the ARS API
    release.api.password        Password for the ARS API
    release.api.token           FOF API Token for the ARS API
    release.cacert				Absolute path to a custom cacert.pem file

    release.core.method              How should I release the CORE version? s3, sftp, ftp, ftps
    release.core.dir                 SFTP directory for the CORE release, relative to ${scp.dir} or ${s3.directory}
    release.core.pattern             Pattern for CORE files
    release.core.update_basename     Update filename, without extension, for the CORE release
    release.core.update_stream       ARS update stream ID for the CORE release
    release.core.access_level        Viewing access level for the CORE release

    release.pro.method              How should I release the PRO version? s3, sftp, ftp, ftps
    release.pro.dir                 SFTP directory for the PRO release, relative to ${scp.dir} or ${s3.directory}
    release.pro.pattern             Pattern for PRO files
    release.pro.update_basename     Update filename, without extension, for the PRO release
    release.pro.update_stream       ARS update stream ID for the PRO release
    release.pro.access_level        Viewing access level for the PRO release

    s3.access               Amazon S3 access key for deploying public uploads
    s3.private              Amazon S3 secret key for deploying public uploads
    s3.bucket               Amazon S3 bucket name for deploying public uploads
    s3.directory            Amazon S3 directory for deploying public uploads
    s3.signature            Amazon S3 signature type (v3, v4)
    s3.region               Amazon S3 region, for v4 signature type

    scp.host                    SFTP hostname
    scp.port                    SFTP port
    scp.username                SFTP username
    scp.password                SFTP password
    scp.dir                     SFTP initial directory
    -->
    <target name="release" depends="setup-properties" description="Use Akeeba Release Maker to deploy software">
        <phingcall target="onBeforeRelease">
        </phingcall>

        <!-- If release.json is not specified use either ${phing.dir}/templates/release.json or
         if it doesn't exist our default release.json file -->
        <if>
            <not>
                <isset property="release.source" />
            </not>
            <then>
				<if>
					<available property="totally.ignored" file="${phing.dir}/templates/release.json" />
					<then>
						<property name="release.source" value="${phing.dir}/templates/release.json" />
					</then>
					<else>
						<property name="release.source" value="${phing.dir.common}/release.json" />
					</else>
				</if>


            </then>
        </if>

        <propertyregex property="dirs.release.translated"
                       override="true"
                       subject="${dirs.release}"
                       pattern="\\"
                       replace="/"
                       casesensitive="true" />
        <propertyregex property="dirs.root.translated"
                       override="true"
                       subject="${dirs.root}"
                       pattern="\\"
                       replace="/"
                       casesensitive="true" />

        <copy file="${release.source}" tofile="${dirs.root}/release.json" overwrite="true">
            <filterchain id="standard-tokens">
                <replacetokens begintoken="##" endtoken="##">
                    <token key="DATE" value="${build.date}" />
                    <token key="VERSION" value="${version}" />

                    <token key="RELEASEDIR" value="${dirs.release.translated}" />
                    <token key="REPODIR" value="${dirs.root.translated}" />
                    <token key="RELEASECATEGORY" value="${release.category}" />
                    <token key="UPDATEMETHOD" value="${release.updatemethod}" />
                    <token key="CUSTOMCACERT" value="${release.cacert}" />
                    <token key="RELEASESTEPS" value="${release.steps}" />

                    <token key="API.ENDPOINT" value="${release.api.endpoint}" />
                    <token key="API.USERNAME" value="${release.api.username}" />
                    <token key="API.PASSWORD" value="${release.api.password}" />
                    <token key="API.TOKEN" value="${release.api.token}" />

                    <token key="S3.ACCESS" value="${s3.access}" />
                    <token key="S3.SECRET" value="${s3.private}" />
                    <token key="S3.BUCKET" value="${s3.bucket}" />
                    <token key="S3.DIRECTORY" value="${s3.directory}" />
                    <token key="UPDATES_DIR" value="${release.update_dir}" />
                    <token key="S3.CDNHOSTNAME" value="${s3.cdnhostname}" />
                    <token key="S3.SIGNATURE" value="${s3.signature}" />
                    <token key="S3.REGION" value="${s3.region}" />

                    <token key="SFTP.HOST" value="${scp.host}" />
                    <token key="SFTP.DIR" value="${scp.dir}" />
                    <token key="SFTP.PORT" value="${scp.port}" />
                    <token key="SFTP.USERNAME" value="${scp.username}" />
                    <token key="SFTP.PASSWORD" value="${scp.password}" />

                    <token key="SFTP.PUBKEYFILE" value="${scp.pubkeyfile}" />
                    <token key="SFTP.PRIVKEYFILE" value="${scp.privkeyfile}" />
                    <token key="SFTP.PRIVKEYFILE.PASS" value="${scp.privkeyfilepassphrase}" />

                    <token key="CORE.METHOD" value="${release.core.method}" />
                    <token key="CORE.DIR" value="${release.core.dir}" />
                    <token key="CORE.PATTERN" value="${release.core.pattern}" />
                    <token key="CORE.UPDATEBASE" value="${release.core.update_basename}" />
                    <token key="CORE.UPDATESTREAM" value="${release.core.update_stream}" />
                    <token key="CORE.ACCESS" value="${release.core.access_level}" />
					<token key="CORE.UPDATEFORMATS" value="${release.core.update.formats}" />

                    <token key="PRO.METHOD" value="${release.pro.method}" />
                    <token key="PRO.DIR" value="${release.pro.dir}" />
                    <token key="PRO.PATTERN" value="${release.pro.pattern}" />
                    <token key="PRO.UPDATEBASE" value="${release.pro.update_basename}" />
                    <token key="PRO.UPDATESTREAM" value="${release.pro.update_stream}" />
                    <token key="PRO.ACCESS" value="${release.pro.access_level}" />
                    <token key="PRO.UPDATEFORMATS" value="${release.pro.update.formats}" />

                    <token key="DOCS.WHERE" value="${release.docs.where}" />
                    <token key="DOCS.WHICH" value="${release.docs.which}" />

                </replacetokens>
            </filterchain>
        </copy>

        <exec executable="${system.php_cli}" dir="${dirs.root}" passthru="true" checkreturn="true">
            <arg file="${dirs.root}/../releasemaker/releasemaker.php" />
			<arg value="--debug" />
            <arg file="${dirs.root}/release.json" />
        </exec>

        <delete file="${dirs.root}/release.json" quiet="true" />

        <phingcall target="onAfterRelease">
        </phingcall>
    </target>

	<!--
	Only re-uploads the update stream to the server.

	This is a modified release task, making sure there is no valid version or core/pro/pdf file upload pattern.
	-->
	<target name="update" depends="setup-properties" description="Use Akeeba Release Maker to deploy software">
		<phingcall target="onBeforeRelease">
		</phingcall>

		<!-- If release.json is not specified use either ${phing.dir}/templates/release.json or
         if it doesn't exist our default release.json file -->
		<if>
			<not>
				<isset property="release.source" />
			</not>
			<then>
				<if>
					<available property="totally.ignored" file="${phing.dir}/templates/release.json" />
					<then>
						<property name="release.source" value="${phing.dir}/templates/release.json" />
					</then>
					<else>
						<property name="release.source" value="${phing.dir.common}/release.json" />
					</else>
				</if>


			</then>
		</if>

		<propertyregex property="dirs.release.translated"
					   override="true"
					   subject="${dirs.release}"
					   pattern="\\"
					   replace="/"
					   casesensitive="true" />
		<propertyregex property="dirs.root.translated"
					   override="true"
					   subject="${dirs.root}"
					   pattern="\\"
					   replace="/"
					   casesensitive="true" />

		<copy file="${release.source}" tofile="${dirs.root}/release.json" overwrite="true">
			<filterchain id="standard-tokens">
				<replacetokens begintoken="##" endtoken="##">
					<token key="DATE" value="${build.date}" />
					<token key="VERSION" value="${version}" />

					<token key="RELEASEDIR" value="${dirs.release.translated}" />
					<token key="REPODIR" value="${dirs.root.translated}" />
					<token key="RELEASECATEGORY" value="${release.category}" />
					<token key="UPDATEMETHOD" value="${release.updatemethod}" />
					<token key="CUSTOMCACERT" value="${release.cacert}" />
					<token key="RELEASESTEPS" value="${release.steps_update}" />

					<token key="API.ENDPOINT" value="${release.api.endpoint}" />
					<token key="API.USERNAME" value="${release.api.username}" />
					<token key="API.PASSWORD" value="${release.api.password}" />
					<token key="API.TOKEN" value="${release.api.token}" />

					<token key="S3.ACCESS" value="${s3.access}" />
					<token key="S3.SECRET" value="${s3.private}" />
					<token key="S3.BUCKET" value="${s3.bucket}" />
					<token key="S3.DIRECTORY" value="${s3.directory}" />
					<token key="UPDATES_DIR" value="${release.update_dir}" />
					<token key="S3.CDNHOSTNAME" value="${s3.cdnhostname}" />
					<token key="S3.SIGNATURE" value="${s3.signature}" />
					<token key="S3.REGION" value="${s3.region}" />

					<token key="SFTP.HOST" value="${scp.host}" />
					<token key="SFTP.DIR" value="${scp.dir}" />
					<token key="SFTP.PORT" value="${scp.port}" />
					<token key="SFTP.USERNAME" value="${scp.username}" />
					<token key="SFTP.PASSWORD" value="${scp.password}" />

					<token key="SFTP.PUBKEYFILE" value="${scp.pubkeyfile}" />
					<token key="SFTP.PRIVKEYFILE" value="${scp.privkeyfile}" />
					<token key="SFTP.PRIVKEYFILE.PASS" value="${scp.privkeyfilepassphrase}" />

					<token key="CORE.METHOD" value="${release.core.method}" />
					<token key="CORE.DIR" value="${release.core.dir}" />
					<token key="CORE.PATTERN" value="XXX_ZZZ_NO_CORE" />
					<token key="CORE.UPDATEBASE" value="${release.core.update_basename}" />
					<token key="CORE.UPDATESTREAM" value="${release.core.update_stream}" />
					<token key="CORE.ACCESS" value="${release.core.access_level}" />
					<token key="CORE.UPDATEFORMATS" value="${release.core.update.formats}" />

					<token key="PRO.METHOD" value="${release.pro.method}" />
					<token key="PRO.DIR" value="${release.pro.dir}" />
					<token key="PRO.PATTERN" value="XXX_ZZZ_NO_PRO" />
					<token key="PRO.UPDATEBASE" value="${release.pro.update_basename}" />
					<token key="PRO.UPDATESTREAM" value="${release.pro.update_stream}" />
					<token key="PRO.ACCESS" value="${release.pro.access_level}" />
					<token key="PRO.UPDATEFORMATS" value="${release.pro.update.formats}" />

					<token key="DOCS.WHERE" value="${release.docs.where}" />
					<token key="DOCS.WHICH" value="[]" />

				</replacetokens>
			</filterchain>
		</copy>

		<exec executable="${system.php_cli}" dir="${dirs.root}" passthru="true" checkreturn="true">
			<arg file="${dirs.root}/../releasemaker/releasemaker.php" />
			<arg value="--debug" />
			<arg file="${dirs.root}/release.json" />
		</exec>

		<delete file="${dirs.root}/release.json" quiet="true" />

		<phingcall target="onAfterRelease">
		</phingcall>
	</target>

    <!-- Runs before "release". Put any custom actions here. You can NOT set/modify variables, see https://www.phing.info/docs/guide/trunk/PhingCallTask.html -->
    <target name="onBeforeRelease">
    </target>

    <!-- Runs after "release". Put any custom actions here. You can NOT set/modify variables, see https://www.phing.info/docs/guide/trunk/PhingCallTask.html -->
    <target name="onAfterRelease">
    </target>

    <!--
    Copy the latest builds of the software to a remote server over SCP. This is normally used with BleedingEdge type
    repositories of Akeeba Release System to provide developer preview releases.

    ftpdeploy.pattern.core      Pattern for Core files, e.g. com_akeeba-*-core.zip
    ftpdeploy.pattern.pro       Pattern for Pro files, e.g. com_akeeba-*-core.zip
    ftpdeploy.path.core         SFTP path to Core files, relative to ${scp.dir}
    ftpdeploy.path.pro          SFTP path to Pro files, relative to ${scp.dir}

    scp.host                    SFTP hostname
    scp.port                    SFTP port
    scp.username                SFTP username
    scp.password                SFTP password
    scp.dir                     SFTP initial directory
    -->
    <target name="ftpdeploy" depends="git">
        <gitversion workingcopy="${dirs.root}" propertyname="git.lastrevision" />

        <if>
            <isset property="ftpdeploy.pattern.core" />
            <then>
                <echo>Uploading Core release</echo>
                <curlsftp
                        host="${scp.host}"
                        port="${scp.port}"
                        username="${scp.username}"
                        password="${scp.password}"
                        pubkeyfile="${scp.pubkeyfile}"
                        privkeyfile="${scp.privkeyfile}"
                        privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                        todir="${scp.dir}/${ftpdeploy.path.core}/${version}"
                        level="debug">
                    <fileset dir="${dirs.root}">
                        <include name="CHANGELOG"/>
                    </fileset>
                    <fileset dir="${dirs.release}">
                        <include name="${ftpdeploy.pattern.core}"/>
                    </fileset>
                </curlsftp>
            </then>
        </if>

        <if>
            <isset property="ftpdeploy.pattern.pro" />
            <then>
                <echo>Uploading Professional release</echo>
                <curlsftp
                        host="${scp.host}"
                        port="${scp.port}"
                        username="${scp.username}"
                        password="${scp.password}"
                        pubkeyfile="${scp.pubkeyfile}"
                        privkeyfile="${scp.privkeyfile}"
                        privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                        todir="${scp.dir}/${ftpdeploy.path.pro}/${version}"
                        level="debug">
                    <fileset dir="${dirs.root}">
                        <include name="CHANGELOG"/>
                    </fileset>
                    <fileset dir="${dirs.release}">
                        <include name="${ftpdeploy.pattern.pro}"/>
                    </fileset>
                </curlsftp>
            </then>
        </if>
    </target>

    <!--
    Internal linker. Symlinks or hardlinks external files / folders into the project
    -->
    <target name="link" description="Internal linker">
        <projectlink repository="${dirs.root}" />
    </target>

    <!--
    Symlink the component, modules and plugins to a Joomla! installation

    site        Absolute filesystem path to the Joomla! installation
    -->
    <target name="relink" description="Joomla! extension relinker">
		<!-- Initialize the site variable if it's not set -->
		<if>
			<equals arg1="${site}" arg2="" />
			<then>
				<property name="site" value="${build.relink_site}" override="true" />
			</then>
		</if>

        <relinksite site="${site}" repository="${dirs.root}" />
    </target>

    <!--
    Symlink the plugin to a WordPress installation

    site        Absolute filesystem path to the Joomla! installation
    -->
    <target name="relinkwp" description="WordPress plugin relinker">
		<!-- Initialize the site variable if it's not set -->
		<if>
			<equals arg1="${sitewp}" arg2="" />
			<then>
				<property name="sitewp" value="${build.relink_sitewp}" override="true" />
			</then>
		</if>

        <relinkwp site="${sitewp}" repository="${dirs.root}" />
    </target>

	<!--
	====================================================================================================
	Tasks - Joomla! packages for FOF 3 extensions
	====================================================================================================
	-->

	<!--
	Builds the Core and Pro installation packages for you. Called by the `git` task. If you need to include other
	stuff –library packages, file packages, template packages, other extension packages not present in this
	repository– you can create a task to put the necessary packages in the `release` folder and then override the
	`component-packages` target, adding the dependencies BEFORE package-pkg. For example:

	<target name="component-packages" depends="my-stuff,some-other-stuff,package-pkg" />

	DO NOT OVERRIDE THE OTHER TASKS INVOLVED IN PACKAGE BUILDING. Please consult the README.md for information.
	-->
	<target name="component-packages" depends="xml-version,package-pkg" />

	<!--
	Modify the XML manifest files applying the build date and version
	-->
	<target name="xml-version" depends="setup-properties">

		<if>
			<and>
				<not>
					<contains string="${version}" substring="rev"/>
				</not>
				<not>
					<contains string="${version}" substring="dev"/>
				</not>
				<not>
					<contains string="${version}" substring="git"/>
				</not>
				<not>
					<contains string="${version}" substring="svn"/>
				</not>
			</and>
			<then>
				<xmlversion repository="${dirs.root}" version="${version}" date="${build.date}"/>
			</then>
		</if>
	</target>

	<!--
	Generates the component installation ZIP files for the Pro and Core releases
	-->
	<target name="package-com" depends="bladejoomla" description="Builds the component">

		<!-- Build the Core package -->
		<phingcall target="package-com-builder">
			<property name="build.is_pro" value="0" />
		</phingcall>

		<if>
			<equals arg1="${build.has_pro}" arg2="1" />
			<then>
				<!-- Build the Pro package -->
				<phingcall target="package-com-builder">
					<property name="build.is_pro" value="1" />
				</phingcall>
			</then>
		</if>

	</target>

	<!--
	Internal builder task to build one component installation package (Core or Pro) at a time
	-->
	<target name="package-com-builder" description="Builds a component package archive">
		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: something.xml -->
				<property name="build.template_xml" value="${build.component}.xml" />
				<!-- Package name: com_something.zip -->
				<property name="build.package_name" value="com_${build.component}.zip" />
				<!-- Fileset reference ID: component -->
				<property name="build.refid" value="component" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: something_core.xml -->
				<property name="build.template_xml" value="${build.component}_${build.suffix}.xml" />
				<!-- Package name: com_something-core.zip -->
				<property name="build.package_name" value="com_${build.component}-${build.suffix}.zip" />
				<!-- Fileset reference ID: component-core -->
				<property name="build.refid" value="component-${build.suffix}" />
			</else>
		</if>

		<!-- Copy the XML manifest file -->
		<if>
			<available file="${phing.dir}/templates/${build.template_xml}" property="completely.ignored" />
			<then>
				<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.component}/${build.component}.xml" overwrite="true">
					<filterchain>
						<replacetokens begintoken="##" endtoken="##">
							<token key="DATE" value="${build.date}" />
							<token key="VERSION" value="${version}" />
							<token key="PRO" value="${build.is_pro}" />
						</replacetokens>
					</filterchain>
				</copy>
			</then>
		</if>

		<!-- Copy the version.php file -->
		<if>
			<available file="${phing.dir}/templates/version.php" property="completely.ignored" />
			<then>
				<copy file="${phing.dir}/templates/version.php" tofile="${dirs.component}/backend/version.php" overwrite="true">
					<filterchain>
						<replacetokens begintoken="##" endtoken="##">
							<token key="DATE" value="${build.date}" />
							<token key="VERSION" value="${version}" />
							<token key="PRO" value="${build.is_pro}" />
						</replacetokens>
					</filterchain>
				</copy>
			</then>
		</if>

		<!-- Create the package ZIP file -->
		<zipme basedir="${dirs.component}" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
			<fileset refid="${build.refid}" />
		</zipme>

		<!-- TODO Rewrite Self-Check to support packages instead of old-style components -->
		<if>
			<equals arg1="${build.selfcheck}" arg2="1" />
			<then>
				<!-- Add self-check file -->
				<exec executable="${system.php_cli}" dir="${dirs.root}" passthru="true" checkreturn="true">
					<arg file="${phing.dir}/build/tools/makeselfcheck.php " />
					<arg file="${dirs.release}/${build.package_name}.zip" />
					<arg value="com_${build.component}" />
					<arg value="${version}" />
					<arg value="${build.date}" />
				</exec>
			</then>
		</if>
	</target>

	<!--
	Builds the CLI file packages
	-->
	<target name="package-files" description="file package for CLI files">
		<if>
			<equals arg1="${build.has_cli}" arg2="1" />
			<then>
				<!-- Build the Core file package -->
				<phingcall target="package-files-builder">
					<property name="build.is_pro" value="0" />
				</phingcall>

				<if>
					<equals arg1="${build.has_pro}" arg2="1" />
					<then>
						<!-- Build the Pro file package -->
						<phingcall target="package-files-builder">
							<property name="build.is_pro" value="1" />
						</phingcall>
					</then>
				</if>
			</then>
		</if>
	</target>

	<!--
	Internal builder task to build one file installation package (Core or Pro) at a time
	-->
	<target name="package-files-builder" description="file package for CLI files">
		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: file_something.xml -->
				<property name="build.template_xml" value="file_${build.component}.xml" />
				<!-- Package name: file_something.zip -->
				<property name="build.package_name" value="file_${build.component}.zip" />
				<!-- Fileset reference ID: cli -->
				<property name="build.refid" value="cli" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: file_something_core.xml -->
				<property name="build.template_xml" value="file_${build.component}_${build.suffix}.xml" />
				<!-- Package name: file_something-core.zip -->
				<property name="build.package_name" value="file_${build.component}-${build.suffix}.zip" />
				<!-- Fileset reference ID: cli-core -->
				<property name="build.refid" value="cli-${build.suffix}" />
			</else>
		</if>

		<!-- TODO If ${phing.dir}/templates/${build.template_xml} not exists do nothing -->
		<if>
			<available file="${phing.dir}/templates/${build.template_xml}" />
			<then>
				<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.component}/cli/file_${build.component}.xml" overwrite="true">
					<filterchain>
						<replacetokens begintoken="##" endtoken="##">
							<token key="DATE" value="${build.date}" />
							<token key="VERSION" value="${version}" />
						</replacetokens>
					</filterchain>
				</copy>

				<zipme basedir="${dirs.component}/cli" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
					<fileset refid="${build.refid}" />
				</zipme>
			</then>
			<else>
				<delete file="${dirs.release}/${build.package_name}" failonerror="false" />
			</else>
		</if>

	</target>

	<!--
	Builds all the modules found in the modules/site and modules/admin folders of your repository
	-->
	<target name="package-modules" description="Build all modules">
		<foreach param="dirname" absparam="absname" target="package-module-folder">
			<fileset dir="${dirs.modules}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to process all modules inside the modules/site or modules/admin folder of your repository
	-->
	<target name="package-module-folder" description="Iterate over the modules in an area (site, admin) directory">
		<property name="module_area" value="${dirname}" />

		<foreach param="module_name" absparam="module_dir" target="package-module-item">
			<fileset dir="${absname}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to build one module installation package at a time
	-->
	<target name="package-module-item" description="Package a single module">
		<echo message="Packaging module ${module_area}/${module_name}" />

		<property name="module_package" value="${dirs.release}/mod_${module_name}.zip" />

		<zipme basedir="${module_dir}" destfile="${module_package}" includeemptydirs="true">
			<fileset dir="${module_dir}">
				<include name="**" />
			</fileset>
		</zipme>
	</target>

	<!--
	Builds all the plugins found in the plugins/* folders of your repository
	-->
	<target name="package-plugins" description="Build all plugins">
		<foreach param="dirname" absparam="absname" target="package-plugin-folder">
			<fileset dir="${dirs.plugins}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to process all plugins inside a plugins/whatever folder of your repository, e.g. plugins/system
	-->
	<target name="package-plugin-folder" description="Iterate over the plugins in an area (system, user, ...) directory">
		<property name="plugin_area" value="${dirname}" />

		<foreach param="plugin_name" absparam="plugin_dir" target="package-plugin-item">
			<fileset dir="${absname}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to build one plugin installation package at a time
	-->
	<target name="package-plugin-item" description="Package a single plugin">
		<echo message="Packaging plugin ${plugin_area}/${plugin_name}" />

		<property name="plugin_package" value="${dirs.release}/plg_${plugin_area}_${plugin_name}.zip" />

		<zipme basedir="${plugin_dir}" destfile="${plugin_package}" includeemptydirs="true">
			<fileset dir="${plugin_dir}">
				<include name="**" />
			</fileset>
		</zipme>
	</target>

	<!--
	Internal task to put the correct FOF 3 package in your release directory as lib_fof30.zip

	If you are building a dev release (the name contains the string dev, rev, git or svn) we'll include a dev build of
	FOF 3. THIS IS NOT RECOMMENDED. It must only be used for TESTING, never on live sites!

	If you are building a regular, numeric versioned released the latest FOF 3 package available from Akeeba Ltd
	will be included instead. THIS IS THE ONLY RECOMMENDED METHOD FOR PUBLIC RELEASES.
	-->
	<target name="package-fof" description="Copy the FOF 3 installation package to the release directory">
        <if>
            <!-- Only build when the build.fof property is true -->
            <istrue value="${build.fof}" />
            <then>
                <if>
                    <or>
                        <contains string="${version}" substring="rev" />
                        <contains string="${version}" substring="dev" />
                        <contains string="${version}" substring="git" />
                        <contains string="${version}" substring="svn" />
                    </or>
                    <then>
                        <!-- Start by building a dev build of FOF... -->
                        <gitversion workingcopy="${dirs.root}/../fof3" propertyname="git.fof.lastrevision" />
                        <gitdate workingcopy="${dirs.root}/../fof3" propertyname="git.fof.timestamp" />
                        <property name="fof.version" value="rev${git.fof.lastrevision}-${git.fof.timestamp}" override="true" />

                        <phing phingfile="build.xml" dir="${dirs.root}/../fof3/build" inheritAll="false" target="git">
                            <property name="dirs.root" value="${dirs.root}/../fof3" />
                            <property name="version" value="${fof.version}" />
                        </phing>

                        <!-- ...and copy it to the release directory -->
                        <copy todir="${dirs.release}" overwrite="true">
                            <mapper type="regexp" from="^(lib_fof30)(-.*)\.zip$" to="\1.zip" />
                            <fileset dir="${dirs.root}/../fof3/release">
                                <include name="lib_fof30-*.zip" />
                            </fileset>
                        </copy>
                    </then>
                    <else>
                        <!-- Get the FOF update XML file -->
                        <httpget url="https://akeeba-cdn.s3.amazonaws.com/updates/fof3_file.xml" dir="${dirs.release}" filename="fof.tmp" followRedirects="true" />

                        <!-- Extract the latest FOF version and download location -->
                        <xslt todir="${dirs.release}" style="${dirs.root}/../buildfiles/tools/foflatest.xslt">
                            <mapper type="glob" from="*.tmp" to="*.xml" />
                            <fileset dir="${dirs.release}">
                                <include name="fof.tmp" />
                            </fileset>
                        </xslt>
                        <delete file="${dirs.release}/fof.tmp" />
                        <xmlproperty file="${dirs.release}/fof.xml" />
                        <echo message="Latest FOF version ${latestFof.version} - ${latestFof.download}" />

                        <!-- Make sure there is a cache directory, or create it -->
                        <if>
                            <available file="${dirs.root}/../buildfiles/cache" />
                            <else>
                                <mkdir dir="${dirs.root}/../buildfiles/cache" />
                            </else>
                        </if>

                        <!-- Get the FOF version from the cache -->
                        <property name="cache_file_exists" value="0" />
                        <available file="${dirs.root}/../buildfiles/cache/fof.xml" property="cache_file_exists" value="1" />

                        <if>
                            <equals arg1="${cache_file_exists}" arg2="1" />
                            <then>
                                <xmlproperty file="${dirs.root}/../buildfiles/cache/fof.xml" keepRoot="false" prefix="fofcache." />
                            </then>
                            <else>
                                <property name="fofcache.version" value="0.0.0" />
                                <property name="fofcache.download" value="" />
                            </else>
                        </if>

                        <echo message="${latestFof.version} - ${fofcache.version}" />

                        <!-- If there is a newer version of FOF available, download it to the cache and update the cached versions -->
                        <php expression="version_compare('${latestFof.version}','${fofcache.version}','gt') ? 1 : 0" returnProperty="has_newer_fof" />
                        <if>
                            <equals arg1="${has_newer_fof}" arg2="1" />
                            <then>
                                <httpget url="${latestFof.download}" dir="${dirs.root}/../buildfiles/cache" filename="lib_fof30.zip" followRedirects="true" />
                                <copy file="${dirs.release}/fof.xml" todir="${dirs.root}/../buildfiles/cache" />
                            </then>
                        </if>

                        <!-- Copy the cached FOF release -->
                        <copy file="${dirs.root}/../buildfiles/cache/lib_fof30.zip" todir="${dirs.release}" />

                        <!-- Clean up -->
                        <delete file="${dirs.release}/fof.xml" />
                    </else>
                </if>
            </then>
        </if>
	</target>

	<!--
Internal task to put the correct FOF 4.x package in your release directory as lib_fof40.zip

If you are building a dev release (the name contains the string dev, rev, git or svn) we'll include a dev build of
FOF 4. THIS IS NOT RECOMMENDED. It must only be used for TESTING, never on live sites!

If you are building a regular, numeric versioned released the latest FOF 4 package available from Akeeba Ltd
will be included instead. THIS IS THE ONLY RECOMMENDED METHOD FOR PUBLIC RELEASES.
-->
	<target name="package-fof4" description="Copy the FOF 4 installation package to the release directory">
		<if>
			<!-- Only build when the build.fof4 property is true -->
			<istrue value="${build.fof4}" />
			<then>
				<if>
					<or>
						<contains string="${version}" substring="rev" />
						<contains string="${version}" substring="dev" />
						<contains string="${version}" substring="git" />
						<contains string="${version}" substring="svn" />
					</or>
					<then>
						<!-- Start by building a dev build of FOF 4.x... -->
						<gitversion workingcopy="${dirs.root}/../fof4" propertyname="git.fof4.lastrevision" />
						<gitdate workingcopy="${dirs.root}/../fof4" propertyname="git.fof4.timestamp" />
						<property name="fof4.version" value="rev${git.fof4.lastrevision}-${git.fof4.timestamp}" override="true" />

						<phing phingfile="build.xml" dir="${dirs.root}/../fof4/build" inheritAll="false" target="git">
							<property name="dirs.root" value="${dirs.root}/../fof4" />
							<property name="version" value="${fof4.version}" />
						</phing>

						<!-- ...and copy it to the release directory -->
						<copy todir="${dirs.release}" overwrite="true">
							<mapper type="regexp" from="^(lib_fof40)(-.*)\.zip$" to="\1.zip" />
							<fileset dir="${dirs.root}/../fof4/release">
								<include name="lib_fof40-*.zip" />
							</fileset>
						</copy>
					</then>
					<else>
						<!-- Get the FOF update XML file -->
						<httpget url="https://akeeba-cdn.s3.amazonaws.com/updates/fof4.xml" dir="${dirs.release}" filename="fof4.tmp" followRedirects="true" />

						<!-- Extract the latest FOF version and download location -->
						<xslt todir="${dirs.release}" style="${dirs.root}/../buildfiles/tools/fof4latest.xslt">
							<mapper type="glob" from="*.tmp" to="*.xml" />
							<fileset dir="${dirs.release}">
								<include name="fof4.tmp" />
							</fileset>
						</xslt>
						<delete file="${dirs.release}/fof4.tmp" />
						<xmlproperty file="${dirs.release}/fof4.xml" />
						<echo message="Latest FOF 4 version ${latestFof4.version} - ${latestFof4.download}" />

						<!-- Make sure there is a cache directory, or create it -->
						<if>
							<available file="${dirs.root}/../buildfiles/cache" />
							<else>
								<mkdir dir="${dirs.root}/../buildfiles/cache" />
							</else>
						</if>

						<!-- Get the FOF version from the cache -->
						<property name="cache_file_exists" value="0" />
						<available file="${dirs.root}/../buildfiles/cache/fof4.xml" property="cache_file_exists" value="1" />

						<if>
							<equals arg1="${cache_file_exists}" arg2="1" />
							<then>
								<xmlproperty file="${dirs.root}/../buildfiles/cache/fof4.xml" keepRoot="false" prefix="fof4cache." />
							</then>
							<else>
								<property name="fof4cache.version" value="0.0.0" />
								<property name="fof4cache.download" value="" />
							</else>
						</if>

						<echo message="${latestFof4.version} - ${fof4cache.version}" />

						<!-- If there is a newer version of FOF available, download it to the cache and update the cached versions -->
						<php expression="version_compare('${latestFof4.version}','${fof4cache.version}','gt') ? 1 : 0" returnProperty="has_newer_fof4" />
						<if>
							<equals arg1="${has_newer_fof4}" arg2="1" />
							<then>
								<httpget url="${latestFof4.download}" dir="${dirs.root}/../buildfiles/cache" filename="lib_fof40.zip" followRedirects="true" />
								<copy file="${dirs.release}/fof4.xml" todir="${dirs.root}/../buildfiles/cache" />
							</then>
						</if>

						<!-- Copy the cached FOF release -->
						<copy file="${dirs.root}/../buildfiles/cache/lib_fof40.zip" todir="${dirs.release}" />

						<!-- Clean up -->
						<delete file="${dirs.release}/fof4.xml" />
					</else>
				</if>
			</then>
		</if>
	</target>

	<!--
	Internal task to put the correct Akeeba Frontend Framework package in your release directory as file_fef.zip

	If you are building a dev release (the name contains the string dev, rev, git or svn) we'll include a dev build of
	FEF. THIS IS NOT RECOMMENDED. It must only be used for TESTING, never on live sites!

	If you are building a regular, numeric versioned released the latest FEF package available from Akeeba Ltd
	will be included instead. THIS IS THE ONLY RECOMMENDED METHOD FOR PUBLIC RELEASES.
	-->
	<target name="package-fef" description="Copy the Akeeba Frontend Framework installation package to the release directory">
		<if>
			<!-- Only build when the build.fef property is true -->
			<istrue value="${build.fef}" />
			<then>
				<if>
					<or>
						<contains string="${version}" substring="rev" />
						<contains string="${version}" substring="dev" />
						<contains string="${version}" substring="git" />
						<contains string="${version}" substring="svn" />
					</or>
					<then>
						<!-- Start by building a dev build of FEF... -->
						<gitversion workingcopy="${dirs.root}/../fef" propertyname="git.fef.lastrevision" />
						<gitdate workingcopy="${dirs.root}/../fef" propertyname="git.fef.timestamp" />
						<property name="fef.version" value="rev${git.fef.lastrevision}-${git.fef.timestamp}" override="true" />

						<phing phingfile="build.xml" dir="${dirs.root}/../fef/build" inheritAll="false" target="git">
							<property name="dirs.root" value="${dirs.root}/../fef" />
							<property name="version" value="${fef.version}" />
						</phing>

						<!-- ...and copy it to the release directory -->
						<copy todir="${dirs.release}" overwrite="true">
							<mapper type="regexp" from="^(file_fef)(-.*)\.zip$" to="\1.zip" />
							<fileset dir="${dirs.root}/../fef/release">
								<include name="file_fef-*.zip" />
							</fileset>
						</copy>
					</then>
					<else>
						<!-- Get the FEF update XML file -->
						<httpget url="https://akeeba-cdn.s3.amazonaws.com/updates/fef.xml" dir="${dirs.release}" filename="fef.tmp" followRedirects="true" />

						<!-- Extract the latest FEF version and download location -->
						<xslt todir="${dirs.release}" style="${dirs.root}/../buildfiles/tools/feflatest.xslt">
							<mapper type="glob" from="*.tmp" to="*.xml" />
							<fileset dir="${dirs.release}">
								<include name="fef.tmp" />
							</fileset>
						</xslt>
						<delete file="${dirs.release}/fef.tmp" />
						<xmlproperty file="${dirs.release}/fef.xml" />
						<echo message="Latest Akeeba FEF version ${latestFEF.version} - ${latestFEF.download}" />

						<!-- Make sure there is a cache directory, or create it -->
						<if>
							<available file="${dirs.root}/../buildfiles/cache" />
							<else>
								<mkdir dir="${dirs.root}/../buildfiles/cache" />
							</else>
						</if>

						<!-- Get the FEF version from the cache -->
						<property name="fef_cache_file_exists" value="0" />
						<available file="${dirs.root}/../buildfiles/cache/fef.xml" property="fef_cache_file_exists" value="1" />

						<if>
							<equals arg1="${fef_cache_file_exists}" arg2="1" />
							<then>
								<xmlproperty file="${dirs.root}/../buildfiles/cache/fef.xml" keepRoot="false" prefix="fefcache." />
							</then>
							<else>
								<property name="fefcache.version" value="0.0.0" />
								<property name="fefcache.download" value="" />
							</else>
						</if>

						<echo message="${latestFEF.version} - ${fefcache.version}" />

						<!-- If there is a newer version of FEF available, download it to the cache and update the cached versions -->
						<php expression="version_compare('${latestFEF.version}','${fefcache.version}','gt') ? 1 : 0" returnProperty="has_newer_fef" />
						<if>
							<equals arg1="${has_newer_fef}" arg2="1" />
							<then>
								<httpget url="${latestFEF.download}" dir="${dirs.root}/../buildfiles/cache" filename="file_fef.zip" followRedirects="true" />
								<copy file="${dirs.release}/fef.xml" todir="${dirs.root}/../buildfiles/cache" />
							</then>
						</if>

						<!-- Copy the cached FEF release -->
						<copy file="${dirs.root}/../buildfiles/cache/file_fef.zip" todir="${dirs.release}" />

						<!-- Clean up -->
						<delete file="${dirs.release}/fef.xml" />
					</else>
				</if>
			</then>
		</if>
	</target>

	<!--
	Builds all Core and Pro packages (pkg_something*.zip)
	-->
	<target name="package-pkg" description="Installation package (pkg_something)" depends="new-release, setup-properties, package-com, package-files, package-modules, package-plugins, package-fof, package-fof4, package-fef">

		<!-- Build the Core package -->
		<phingcall target="package-pkg-builder">
			<property name="build.is_pro" value="0" />
		</phingcall>

		<if>
			<equals arg1="${build.has_pro}" arg2="1" />
			<then>
				<!-- Build the Pro package -->
				<phingcall target="package-pkg-builder">
					<property name="build.is_pro" value="1" />
				</phingcall>

				<!-- Clean up -->
				<delete>
					<fileset refid="package-core" />
					<fileset refid="package-pro" />
				</delete>
			</then>
			<else>
				<!-- Clean up -->
				<delete>
					<fileset refid="package" />
				</delete>
			</else>
		</if>

	</target>

	<!--
	Internal task to build one installation package (Core or Pro) at a time.
	-->
	<target name="package-pkg-builder" description="Create an installation package">

		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: pkg_something.xml -->
				<property name="build.template_xml" value="pkg_${build.component}.xml" />
				<!-- Package name: pkg_something-1.2.3.zip -->
				<property name="build.package_name" value="pkg_${build.component}-${version}.zip" />
				<!-- Fileset reference ID: package -->
				<property name="build.refid" value="package" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: pkg_something_core.xml -->
				<property name="build.template_xml" value="pkg_${build.component}_${build.suffix}.xml" />
				<!-- Package name: pkg_something-1.2.3-core.zip -->
				<property name="build.package_name" value="pkg_${build.component}-${version}-${build.suffix}.zip" />
				<!-- Fileset reference ID: package-core -->
				<property name="build.refid" value="package-${build.suffix}" />
			</else>
		</if>

		<!-- Create the XML manifest. IMPORTANT: THE TARGET NAME IS ALWAYS pkg_something.xml WITHOUT A SUFFIX TO ALLOW
		 JOOMLA! TO UPGRADE FROM CORE TO PRO WITHOUT SCREWING UP THE #__extensions ENTRIES!!! -->
		<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.release}/pkg_${build.component}.xml" overwrite="true">
			<filterchain>
				<replacetokens begintoken="##" endtoken="##">
					<token key="DATE" value="${build.date}" />
					<token key="VERSION" value="${version}" />
				</replacetokens>
			</filterchain>
		</copy>

		<!-- Copy the LICENSE.txt file, if present -->
		<if>
			<available property="completely.ignored" file="${dirs.component}/LICENSE.txt" />
			<then>
				<copy file="${dirs.component}/LICENSE.txt" tofile="${dirs.release}/LICENSE.txt" overwrite="true" />
			</then>
		</if>

		<!-- Copy the script.something.php installation script file, if present -->
		<if>
			<available property="completely.ignored" file="${phing.dir}/templates/script.${build.component}.php" />
			<then>
				<copy file="${phing.dir}/templates/script.${build.component}.php" tofile="${dirs.release}/script.${build.component}.php" overwrite="true" />
			</then>
		</if>
		<if>
			<available property="completely.ignored" file="${dirs.component}/script.${build.component}.php" />
			<then>
				<copy file="${dirs.component}/script.${build.component}.php" tofile="${dirs.release}/script.${build.component}.php" overwrite="true" />
			</then>
		</if>

		<!-- Create the ZIP file -->
		<zipme basedir="${dirs.release}" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
			<fileset refid="${build.refid}" />
		</zipme>
	</target>

    <target name="lang">
        <echo message="The lang task is obsolete." />
    </target>

	<target name="bladejoomla" description="Precompiles Blade templates for Joomla! components">
		<!-- Remove the PrecompiledTemplates folders from the front- and backend -->
		<delete quiet="true" includeemptydirs="true" dir="${dirs.component}/frontend/PrecompiledTemplates" />
		<delete quiet="true" includeemptydirs="true" dir="${dirs.component}/backend/PrecompiledTemplates" />

		<if>
			<equals arg1="${build.precompile_blade}" arg2="1" />
			<then>
				<!-- Precompile all Blade templates -->
				<bladejoomla site="${site}" component="com_${build.component}">
					<dirset dir="${dirs.component}/frontend">
						<include name="views" />
						<include name="View" />
						<include name="ViewTemplates" />
					</dirset>
					<dirset dir="${dirs.component}/backend">
						<include name="views" />
						<include name="View" />
						<include name="ViewTemplates" />
					</dirset>
				</bladejoomla>
			</then>
		</if>
	</target>

    <target name="info">
        <php function="php_ini_loaded_file" returnProperty="inifiles" />
        <php function="php_ini_scanned_files" returnProperty="extrainifiles" />

        <echo message="Phing v.${phing.version} running on ${os.name}" />
        <echo message="Host OS ${host.os} release ${host.os.release} version ${host.os.version}" />
        <echo message="PHP version: ${php.version}" />
        <echo message="PHP ini file: ${inifiles}" />
        <echo message="PHP additional ini files: ${extrainifiles}" />
        <echo message="Host architecture ${host.arch} – fstype ${host.fstype}" />
        <echo message="Host domain ${host.domain}" />
        <echo message="CWD ${application.startdir}" />
        <echo message="phing.file ${phing.file}" />
        <echo message="phing.home ${phing.home}" />
        <echo message="phing.dir ${phing.dir}" />
        <echo message="phing.project.name ${phing.project.name}" />
        <echo message="project.basedir ${project.basedir}" />
    </target>
</project>
