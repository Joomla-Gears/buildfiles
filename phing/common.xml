<?xml version="1.0"?>
<!--
Akeeba Build Files

@package    buildfiles
@copyright  (c) 2010-2017 Akeeba Ltd
-->
<project name="common" basedir="." description="Common phing tasks for building Joomla! extensions"
         default="git">
    <!--
    You need to import this file in your main Phing file like this:

    <import file="${phing.dir}/../../buildfiles/phing/common.xml" />
    -->

    <!-- Built in properties -->
    <!-- ### Project Paths -->
    <property name="dirs.root" value="${phing.dir}/.." />
    <property name="dirs.release" value="${dirs.root}/release" />
    <!-- ### Software and Documentation Paths -->
    <property name="dirs.component" value="${dirs.root}/component" />
    <property name="dirs.modules" value="${dirs.root}/modules" />
    <property name="dirs.plugins" value="${dirs.root}/plugins" />
    <property name="dirs.documentation" value="${dirs.root}/documentation" />
    <!-- ### DocBook XML Stylesheet Paths -->
    <property name="dirs.bin" value="${phing.dir.common}/bin" />
    <property name="dirs.bin.libxml" value="${dirs.bin}/libxml" />
    <property name="dirs.bin.fop" value="${dirs.bin}/fop" />
    <property name="dirs.bin.dbxsl" value="${dirs.bin}/dbxsl" />
	<!-- ### Should I include Strapper in the build? -->
	<property name="build.strapper" value="1" />
    <!-- ### Should I include FOF in the build? -->
	<property name="build.fof" value="1" />

    <!-- ### Version numbers -->
    <property name="version" value="git" />

    <!-- Load externally defined properties -->
    <!-- ### Default properties, located next to the common.xml file -->
    <property file="${phing.dir.common}/default.properties" />
    <!-- ### Common properties, stored one level above the repository's root -->
    <property file="${phing.dir}/../../build.properties" override="true" />
    <!-- ### Project properties -->
    <property file="${phing.dir}/build.properties" override="true" />
    <!-- ### Overrides, per project -->
    <property file="${phing.dir}/override.properties" override="true" />

    <!-- Custom task definitions -->
    <includepath classpath="${phing.dir.common}" />

    <taskdef name="gitdate" classname="tasks.GitDateTask" />
    <taskdef name="GitHubAsset" classname="tasks.GitHubAssetTask" />
    <taskdef name="GitHubRelease" classname="tasks.GitHubReleaseTask" />
    <taskdef name="gitversion" classname="tasks.GitVersionTask" />
    <taskdef name="jpa" classname="tasks.JPATask" />
    <taskdef name="link" classname="tasks.LinkTask" />
    <taskdef name="projectlink" classname="tasks.ProjectLinkTask" />
    <taskdef name="relinksite" classname="tasks.RelinkSiteTask" />
    <taskdef name="zipme" classname="tasks.ZipmeTask" />

	<!--
	Generate the installation packages and the documentation
	-->
	<target name="all" description="Makes everything"
			depends="git,documentation">
	</target>

	<!--
	Generate the installation packages. By default it generates a development build. You can pass a specific version
	number to make a numbered version release, e.g. `phing git -Dversion=1.2.3` to build version 1.2.3
	-->
	<target name="git" description="Makes only packages, not the documentation"
			depends="new-release,setup-properties,component-packages">
	</target>

    <!--
    Set up the basic version and build properties required to build files
    -->
    <target name="setup-properties" description="Set up version and build properties">
        <!-- Initialize the build.date timestamp -->
        <tstamp>
            <format property="build.date" pattern="%Y-%m-%d" />
        </tstamp>

        <!-- Initialize the version if it's not set -->
        <if>
            <equals arg1="${version}" arg2="git" />
            <then>
                <gitversion workingcopy="${dirs.root}" propertyname="git.lastrevision" />
                <property name="version" value="rev${git.lastrevision}" override="true" />
            </then>
        </if>
    </target>

    <!--
    Creates the release directory afresh before building anything
    -->
    <target name="new-release" description="Create afresh the release directory">
        <delete dir="${dirs.release}" quiet="true" includeemptydirs="true" />
        <mkdir dir="${dirs.release}" />
    </target>

    <!--
    Transforms a DocBook XML file to PDF format

    docs.input      DocBook XML filename relative to dirs.documentation
    -->
    <target name="docbook-pdf" description="Render documentation in PDF format">
        <basename property="docs.output" file="${docs.input}" suffix=".xml" />

        <exec executable="xsltproc" dir="${dirs.documentation}">
            <arg value="--nonet" />
            <arg value="--xinclude" />
            <arg value="--novalid" />

            <arg value="--stringparam" />
            <arg value="body.start.indent" />
            <arg value="0" />

            <arg value="--stringparam" />
            <arg value="variablelist.term.break.after 1" />
            <arg value="1" />

            <arg value="--stringparam" />
            <arg value="variablelist.term.separator" />
            <arg value="&quot;&quot;" />

            <arg value="--stringparam" />
            <arg value="variablelist.max.termlength" />
            <arg value="12" />

            <arg value="--stringparam" />
            <arg value="section.autolabel" />
            <arg value="1" />

            <arg value="--stringparam" />
            <arg value="toc.section.depth" />
            <arg value="5" />

            <arg value="--stringparam" />
            <arg value="fop1.extensions" />
            <arg value="1" />

            <arg value="--output" />
            <arg file="${dirs.release}/${docs.output}.fo" />

            <arg file="${dirs.bin.dbxsl}/fo/docbook.xsl" />

            <arg file="${dirs.documentation}/${docs.input}" />
        </exec>

        <exec executable="${dirs.bin.fop}/fop" dir="${dirs.documentation}">
            <arg value="-fo" />
            <arg file="${dirs.release}/${docs.output}.fo" />

            <arg value="-pdf" />
            <arg file="${dirs.release}/${docs.output}.pdf" />
        </exec>

        <delete file="${dirs.release}/${docs.output}.fo" quiet="true" />
    </target>

    <!--
    Transforms a DocBook XML file to ePub format

    docs.input      DocBook XML filename relative to dirs.documentation
    -->
    <target name="docbook-epub" description="Render documentation in ePub format">
        <basename property="docs.output" file="${docs.input}" suffix=".xml" />
        <dirname property="docs.images" file="${docs.input}" />

        <property name="docs.epubdir" value="${dirs.release}/tmp_${docs.output}" />

        <mkdir dir="${docs.epubdir}" />
        <mkdir dir="${docs.epubdir}/OEBPS" />
        <mkdir dir="${docs.epubdir}/OEBPS/images" />
        <copy todir="${docs.epubdir}/OEBPS/images">
            <fileset dir="${dirs.documentation}/${docs.images}">
                <include name="*.png" />
                <include name="*.jpg" />
                <include name="*.jpeg" />
                <include name="*.gif" />
            </fileset>
        </copy>

        <exec executable="xsltproc" dir="${dirs.documentation}">
            <arg value="--nonet" />
            <arg value="--xinclude" />
            <arg value="--novalid" />

            <arg value="--stringparam" />
            <arg value="epub.stylesheet" />
            <arg value="style.css" />



            <arg value="--stringparam" />
            <arg value="body.start.indent" />
            <arg value="0" />

            <arg value="--stringparam" />
            <arg value="variablelist.term.break.after 1" />
            <arg value="1" />

            <arg value="--stringparam" />
            <arg value="variablelist.term.separator" />
            <arg value="&quot;&quot;" />

            <arg value="--stringparam" />
            <arg value="variablelist.max.termlength" />
            <arg value="12" />

            <arg value="--stringparam" />
            <arg value="section.autolabel" />
            <arg value="1" />

            <arg value="--stringparam" />
            <arg value="toc.section.depth" />
            <arg value="5" />

            <arg value="--output" />
            <arg file="${docs.epubdir}/${docs.output}.epub" />

            <arg file="${dirs.bin.dbxsl}/epub3/chunk.xsl" />

            <arg file="${dirs.documentation}/${docs.input}" />
        </exec>

        <copy file="${phing.dir.common}/epub/mimetype" tofile="${docs.epubdir}/mimetype" overwrite="true" />
        <copy file="${phing.dir.common}/epub/com.apple.ibooks.display-options.xml" tofile="${docs.epubdir}/META-INF/com.apple.ibooks.display-options.xml" overwrite="true" />
        <copy file="${phing.dir.common}/epub/docbook-epub.css" tofile="${docs.epubdir}/OEBPS/docbook-epub.css" overwrite="true" />

        <zip destfile="${dirs.release}/${docs.output}.epub" basedir="${docs.epubdir}">
            <fileset dir="${docs.epubdir}">
                <include name="**" />
            </fileset>
        </zip>

        <delete dir="${docs.epubdir}" quiet="true" />
    </target>

    <!--
    Copy DocBook XML documentation to the remote server, for use by Akeeba DocImport³

    scp.dir.docs            Absolute SFTP path where documentation files are stored
    docsdeploy.path.source  Path to the documentation source, relative to ${dirs.documentation}
    docsdeploy.path.target  SFTP path to uploaded documentation, relative to ${scp.dir.docs}
    -->
    <target name="docbook-deploy" >
        <basename property="docsdeploy.name" file="${docsdeploy.path.source}" />
        <echo>Uploading ${docsdeploy.name}</echo>
        <scp
                host="${scp.host}"
                port="${scp.port}"
                username="${scp.username}"
                password="${scp.password}"
                pubkeyfile="${scp.pubkeyfile}"
                privkeyfile="${scp.privkeyfile}"
                privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                todir="${scp.dir.docs}/${docsdeploy.path.target}"
                level="debug">
            <fileset dir="${dirs.documentation}/${docsdeploy.path.source}">
                <include name="*.xml"/>
                <include name="images/**"/>
            </fileset>
        </scp>
    </target>

    <!--
    Uses Akeeba Release maker to deploy new releases to a remote Akeeba Release System installation.

    release.source              Absolute path and filename to the release.json prototype we're going to use
    release.api.endpoint        URL to the ARS API endpoint
    release.api.username        Username for the ARS API
    release.api.password        Password for the ARS API

    release.core.method              How should I release the CORE version? s3, sftp, ftp, ftps
    release.core.dir                 SFTP directory for the CORE release, relative to ${scp.dir} or ${s3.directory}
    release.core.pattern             Pattern for CORE files
    release.core.update_basename     Update filename, without extension, for the CORE release
    release.core.update_stream       ARS update stream ID for the CORE release
    release.core.subscription_levels List of subscription levels for the CORE release
    release.core.access_level        Viewing access level for the CORE release

    release.pro.method              How should I release the PRO version? s3, sftp, ftp, ftps
    release.pro.dir                 SFTP directory for the PRO release, relative to ${scp.dir} or ${s3.directory}
    release.pro.pattern             Pattern for PRO files
    release.pro.update_basename     Update filename, without extension, for the PRO release
    release.pro.update_stream       ARS update stream ID for the PRO release
    release.pro.subscription_levels List of subscription levels for the PRO release
    release.pro.access_level        Viewing access level for the PRO release

    s3.access               Amazon S3 access key for deploying public uploads
    s3.private              Amazon S3 secret key for deploying public uploads
    s3.bucket               Amazon S3 bucket name for deploying public uploads
    s3.directory            Amazon S3 directory for deploying public uploads

    scp.host                    SFTP hostname
    scp.port                    SFTP port
    scp.username                SFTP username
    scp.password                SFTP password
    scp.dir                     SFTP initial directory
    -->
    <target name="release" depends="setup-properties" description="Use Akeeba Release Maker to deploy software">
        <phingcall target="onBeforeRelease">
        </phingcall>

        <!-- If release.json is not specified use either ${phing.dir}/templates/release.json or
         if it doesn't exist our default release.json file -->
        <if>
            <not>
                <isset property="release.source" />
            </not>
            <then>
				<if>
					<available property="totally.ignored" file="${phing.dir}/templates/release.json" />
					<then>
						<property name="release.source" value="${phing.dir}/templates/release.json" />
					</then>
					<else>
						<property name="release.source" value="${phing.dir.common}/release.json" />
					</else>
				</if>


            </then>
        </if>

        <propertyregex property="dirs.release.translated"
                       override="true"
                       subject="${dirs.release}"
                       pattern="\\"
                       replace="/"
                       casesensitive="true" />
        <propertyregex property="dirs.root.translated"
                       override="true"
                       subject="${dirs.root}"
                       pattern="\\"
                       replace="/"
                       casesensitive="true" />

        <copy file="${release.source}" tofile="${dirs.root}/release.json" overwrite="true">
            <filterchain id="standard-tokens">
                <replacetokens begintoken="##" endtoken="##">
                    <token key="DATE" value="${build.date}" />
                    <token key="VERSION" value="${version}" />

                    <token key="RELEASEDIR" value="${dirs.release.translated}" />
                    <token key="REPODIR" value="${dirs.root.translated}" />
                    <token key="RELEASECATEGORY" value="${release.category}" />
                    <token key="UPDATEMETHOD" value="${release.updatemethod}" />

                    <token key="API.ENDPOINT" value="${release.api.endpoint}" />
                    <token key="API.USERNAME" value="${release.api.username}" />
                    <token key="API.PASSWORD" value="${release.api.password}" />

                    <token key="S3.ACCESS" value="${s3.access}" />
                    <token key="S3.SECRET" value="${s3.private}" />
                    <token key="S3.BUCKET" value="${s3.bucket}" />
                    <token key="S3.DIRECTORY" value="${s3.directory}" />
                    <token key="UPDATES_DIR" value="${release.update_dir}" />
                    <token key="S3.CDNHOSTNAME" value="${s3.cdnhostname}" />

                    <token key="SFTP.HOST" value="${scp.host}" />
                    <token key="SFTP.DIR" value="${scp.dir}" />
                    <token key="SFTP.PORT" value="${scp.port}" />
                    <token key="SFTP.USERNAME" value="${scp.username}" />
                    <token key="SFTP.PASSWORD" value="${scp.password}" />

                    <token key="SFTP.PUBKEYFILE" value="${scp.pubkeyfile}" />
                    <token key="SFTP.PRIVKEYFILE" value="${scp.privkeyfile}" />
                    <token key="SFTP.PRIVKEYFILE.PASS" value="${scp.privkeyfilepassphrase}" />

                    <token key="CORE.METHOD" value="${release.core.method}" />
                    <token key="CORE.DIR" value="${release.core.dir}" />
                    <token key="CORE.PATTERN" value="${release.core.pattern}" />
                    <token key="CORE.UPDATEBASE" value="${release.core.update_basename}" />
                    <token key="CORE.UPDATESTREAM" value="${release.core.update_stream}" />
                    <token key="CORE.SUBSCRIPTIONS" value="${release.core.subscription_levels}" />
                    <token key="CORE.ACCESS" value="${release.core.access_level}" />

                    <token key="PRO.METHOD" value="${release.pro.method}" />
                    <token key="PRO.DIR" value="${release.pro.dir}" />
                    <token key="PRO.PATTERN" value="${release.pro.pattern}" />
                    <token key="PRO.UPDATEBASE" value="${release.pro.update_basename}" />
                    <token key="PRO.UPDATESTREAM" value="${release.pro.update_stream}" />
                    <token key="PRO.SUBSCRIPTIONS" value="${release.pro.subscription_levels}" />
                    <token key="PRO.ACCESS" value="${release.pro.access_level}" />

                    <token key="DOCS.WHERE" value="${release.docs.where}" />
                    <token key="DOCS.WHICH" value="${release.docs.which}" />

                </replacetokens>
            </filterchain>
        </copy>

        <exec executable="php" dir="${dirs.root}" passthru="true">
            <arg file="${dirs.root}/../releasemaker/releasemaker/index.php" />
            <arg file="${dirs.root}/release.json" />
        </exec>

        <delete file="${dirs.root}/release.json" quiet="true" />

        <phingcall target="onAfterRelease">
        </phingcall>
    </target>

    <!-- Runs before "release". Put any custom actions here. You can NOT set/modify variables, see https://www.phing.info/docs/guide/trunk/PhingCallTask.html -->
    <target name="onBeforeRelease">
    </target>

    <!-- Runs after "release". Put any custom actions here. You can NOT set/modify variables, see https://www.phing.info/docs/guide/trunk/PhingCallTask.html -->
    <target name="onAfterRelease">
    </target>

    <!--
    Copy the latest builds of the software to a remote server over SCP. This is normally used with BleedingEdge type
    repositories of Akeeba Release System to provide developer preview releases.

    ftpdeploy.pattern.core      Pattern for Core files, e.g. com_akeeba-*-core.zip
    ftpdeploy.pattern.pro       Pattern for Pro files, e.g. com_akeeba-*-core.zip
    ftpdeploy.path.core         SFTP path to Core files, relative to ${scp.dir}
    ftpdeploy.path.pro          SFTP path to Pro files, relative to ${scp.dir}

    scp.host                    SFTP hostname
    scp.port                    SFTP port
    scp.username                SFTP username
    scp.password                SFTP password
    scp.dir                     SFTP initial directory
    -->
    <target name="ftpdeploy" depends="git">
        <gitversion workingcopy="${dirs.root}" propertyname="git.lastrevision" />

        <if>
            <isset property="ftpdeploy.pattern.core" />
            <then>
                <echo>Uploading Core release</echo>
                <scp
                        host="${scp.host}"
                        port="${scp.port}"
                        username="${scp.username}"
                        password="${scp.password}"
                        pubkeyfile="${scp.pubkeyfile}"
                        privkeyfile="${scp.privkeyfile}"
                        privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                        todir="${scp.dir}/${ftpdeploy.path.core}/${version}"
                        level="debug">
                    <fileset dir="${dirs.root}">
                        <include name="CHANGELOG"/>
                    </fileset>
                    <fileset dir="${dirs.release}">
                        <include name="${ftpdeploy.pattern.core}"/>
                    </fileset>
                </scp>
            </then>
        </if>

        <if>
            <isset property="ftpdeploy.pattern.pro" />
            <then>
                <echo>Uploading Professional release</echo>
                <scp
                        host="${scp.host}"
                        port="${scp.port}"
                        username="${scp.username}"
                        password="${scp.password}"
                        pubkeyfile="${scp.pubkeyfile}"
                        privkeyfile="${scp.privkeyfile}"
                        privkeyfilepassphrase="${scp.privkeyfilepassphrase}"
                        todir="${scp.dir}/${ftpdeploy.path.pro}/${version}"
                        level="debug">
                    <fileset dir="${dirs.root}">
                        <include name="CHANGELOG"/>
                    </fileset>
                    <fileset dir="${dirs.release}">
                        <include name="${ftpdeploy.pattern.pro}"/>
                    </fileset>
                </scp>
            </then>
        </if>
    </target>

    <!--
    Internal linker. Symlinks or hardlinks external files / folders into the project
    -->
    <target name="link" description="Internal linker">
        <projectlink repository="${dirs.root}" />
    </target>

    <!--
    Symlink the component, modules and plugins to a Joomla! installation

    site        Absolute filesystem path to the Joomla! installation
    -->
    <target name="relink" description="Project relinker">
        <relinksite site="${site}" repository="${dirs.root}" />
    </target>

	<!--
	====================================================================================================
	Tasks - Joomla! packages for FOF 3 extensions
	====================================================================================================
	-->

	<!--
	Builds the Core and Pro installation packages for you. Called by the `git` task. If you need to include other
	stuff –library packages, file packages, template packages, other extension packages not present in this
	repository– you can create a task to put the necessary packages in the `release` folder and then override the
	`component-packages` target, adding the dependencies BEFORE package-pkg. For example:

	<target name="component-packages" depends="my-stuff,some-other-stuff,package-pkg" />

	DO NOT OVERRIDE THE OTHER TASKS INVOLVED IN PACKAGE BUILDING. Please consult the README.md for information.
	-->
	<target name="component-packages" depends="package-pkg" />

	<!--
	Generates the component installation ZIP files for the Pro and Core releases
	-->
	<target name="package-com" description="Builds the component">

		<!-- Build the Core package -->
		<phingcall target="package-com-builder">
			<property name="build.is_pro" value="0" />
		</phingcall>

		<if>
			<equals arg1="${build.has_pro}" arg2="1" />
			<then>
				<!-- Build the Pro package -->
				<phingcall target="package-com-builder">
					<property name="build.is_pro" value="1" />
				</phingcall>
			</then>
		</if>

	</target>

	<!--
	Internal builder task to build one component installation package (Core or Pro) at a time
	-->
	<target name="package-com-builder" description="Builds a component package archive">
		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: something.xml -->
				<property name="build.template_xml" value="${build.component}.xml" />
				<!-- Package name: com_something.zip -->
				<property name="build.package_name" value="com_${build.component}.zip" />
				<!-- Fileset reference ID: component -->
				<property name="build.refid" value="component" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: something_core.xml -->
				<property name="build.template_xml" value="${build.component}_${build.suffix}.xml" />
				<!-- Package name: com_something-core.zip -->
				<property name="build.package_name" value="com_${build.component}-${build.suffix}.zip" />
				<!-- Fileset reference ID: component-core -->
				<property name="build.refid" value="component-${build.suffix}" />
			</else>
		</if>

		<!-- Copy the XML manifest file -->
		<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.component}/${build.component}.xml" overwrite="true">
			<filterchain>
				<replacetokens begintoken="##" endtoken="##">
					<token key="DATE" value="${build.date}" />
					<token key="VERSION" value="${version}" />
					<token key="PRO" value="${build.is_pro}" />
				</replacetokens>
			</filterchain>
		</copy>

		<!-- Copy the version.php file -->
		<if>
			<available file="${phing.dir}/templates/version.php" property="completely.ignored" />
			<then>
				<copy file="${phing.dir}/templates/version.php" tofile="${dirs.component}/backend/version.php" overwrite="true">
					<filterchain>
						<replacetokens begintoken="##" endtoken="##">
							<token key="DATE" value="${build.date}" />
							<token key="VERSION" value="${version}" />
							<token key="PRO" value="${build.is_pro}" />
						</replacetokens>
					</filterchain>
				</copy>
			</then>
		</if>

		<!-- Create the package ZIP file -->
		<zipme basedir="${dirs.component}" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
			<fileset refid="${build.refid}" />
		</zipme>

		<!-- TODO Rewrite Self-Check to support packages instead of old-style components -->
		<if>
			<equals arg1="${build.selfcheck}" arg2="1" />
			<then>
				<!-- Add self-check file -->
				<exec executable="php" dir="${dirs.root}" passthru="true">
					<arg file="${phing.dir}/build/tools/makeselfcheck.php " />
					<arg file="${dirs.release}/${build.package_name}.zip" />
					<arg value="com_${build.component}" />
					<arg value="${version}" />
					<arg value="${build.date}" />
				</exec>
			</then>
		</if>
	</target>

	<!--
	Builds the CLI file packages
	-->
	<target name="package-files" description="file package for CLI files">
		<if>
			<equals arg1="${build.has_cli}" arg2="1" />
			<then>
				<!-- Build the Core file package -->
				<phingcall target="package-files-builder">
					<property name="build.is_pro" value="0" />
				</phingcall>

				<if>
					<equals arg1="${build.has_pro}" arg2="1" />
					<then>
						<!-- Build the Pro file package -->
						<phingcall target="package-files-builder">
							<property name="build.is_pro" value="1" />
						</phingcall>
					</then>
				</if>
			</then>
		</if>
	</target>

	<!--
	Internal builder task to build one file installation package (Core or Pro) at a time
	-->
	<target name="package-files-builder" description="file package for CLI files">
		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: file_something.xml -->
				<property name="build.template_xml" value="file_${build.component}.xml" />
				<!-- Package name: file_something.zip -->
				<property name="build.package_name" value="file_${build.component}.zip" />
				<!-- Fileset reference ID: cli -->
				<property name="build.refid" value="cli" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: file_something_core.xml -->
				<property name="build.template_xml" value="file_${build.component}_${build.suffix}.xml" />
				<!-- Package name: file_something-core.zip -->
				<property name="build.package_name" value="file_${build.component}-${build.suffix}.zip" />
				<!-- Fileset reference ID: cli-core -->
				<property name="build.refid" value="cli-${build.suffix}" />
			</else>
		</if>

		<!-- TODO If ${phing.dir}/templates/${build.template_xml} not exists do nothing -->
		<if>
			<available file="${phing.dir}/templates/${build.template_xml}" />
			<then>
				<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.component}/cli/file_${build.component}.xml" overwrite="true">
					<filterchain>
						<replacetokens begintoken="##" endtoken="##">
							<token key="DATE" value="${build.date}" />
							<token key="VERSION" value="${version}" />
						</replacetokens>
					</filterchain>
				</copy>

				<zipme basedir="${dirs.component}/cli" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
					<fileset refid="${build.refid}" />
				</zipme>
			</then>
			<else>
				<delete file="${dirs.release}/${build.package_name}" failonerror="false" />
			</else>
		</if>

	</target>

	<!--
	Builds all the modules found in the modules/site and modules/admin folders of your repository
	-->
	<target name="package-modules" description="Build all modules">
		<foreach param="dirname" absparam="absname" target="package-module-folder">
			<fileset dir="${dirs.modules}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to process all modules inside the modules/site or modules/admin folder of your repository
	-->
	<target name="package-module-folder" description="Iterate over the modules in an area (site, admin) directory">
		<property name="module_area" value="${dirname}" />

		<foreach param="module_name" absparam="module_dir" target="package-module-item">
			<fileset dir="${absname}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to build one module installation package at a time
	-->
	<target name="package-module-item" description="Package a single module">
		<echo message="Packaging module ${module_area}/${module_name}" />

		<property name="module_package" value="${dirs.release}/mod_${module_name}.zip" />

		<zipme basedir="${module_dir}" destfile="${module_package}" includeemptydirs="true">
			<fileset dir="${module_dir}">
				<include name="**" />
			</fileset>
		</zipme>
	</target>

	<!--
	Builds all the plugins found in the plugins/* folders of your repository
	-->
	<target name="package-plugins" description="Build all plugins">
		<foreach param="dirname" absparam="absname" target="package-plugin-folder">
			<fileset dir="${dirs.plugins}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to process all plugins inside a plugins/whatever folder of your repository, e.g. plugins/system
	-->
	<target name="package-plugin-folder" description="Iterate over the plugins in an area (system, user, ...) directory">
		<property name="plugin_area" value="${dirname}" />

		<foreach param="plugin_name" absparam="plugin_dir" target="package-plugin-item">
			<fileset dir="${absname}">
				<type type="dir" />
				<depth max="0" min="0" />
			</fileset>
		</foreach>
	</target>

	<!--
	Internal builder task to build one plugin installation package at a time
	-->
	<target name="package-plugin-item" description="Package a single plugin">
		<echo message="Packaging plugin ${plugin_area}/${plugin_name}" />

		<property name="plugin_package" value="${dirs.release}/plg_${plugin_area}_${plugin_name}.zip" />

		<zipme basedir="${plugin_dir}" destfile="${plugin_package}" includeemptydirs="true">
			<fileset dir="${plugin_dir}">
				<include name="**" />
			</fileset>
		</zipme>
	</target>

	<!--
	Internal task to put the correct FOF 3 package in your release directory as lib_fof30.zip

	If you are building a dev release (the name contains the string dev, rev, git or svn) we'll include a dev build of
	FOF 3. THIS IS NOT RECOMMENDED. It must only be used for TESTING, never on live sites!

	If you are building a regular, numeric versioned released the latest FOF 3 package available from akeebabackup.com
	will be included instead. THIS IS THE ONLY RECOMMENDED METHOD FOR PUBLIC RELEASES.
	-->
	<target name="package-fof" description="Copy the FOF 3 installation package to the release directory">
        <if>
            <!-- Only build when the build.fof property is true -->
            <istrue value="${build.fof}" />
            <then>
                <if>
                    <or>
                        <contains string="${version}" substring="rev" />
                        <contains string="${version}" substring="dev" />
                        <contains string="${version}" substring="git" />
                        <contains string="${version}" substring="svn" />
                    </or>
                    <then>
                        <!-- Start by building a dev build of FOF... -->
                        <gitversion workingcopy="${dirs.root}/../fof3" propertyname="git.fof.lastrevision" />
                        <gitdate workingcopy="${dirs.root}/../fof3" propertyname="git.fof.timestamp" />
                        <property name="fof.version" value="rev${git.fof.lastrevision}-${git.fof.timestamp}" override="true" />

                        <phing phingfile="build.xml" dir="${dirs.root}/../fof3/build" inheritAll="false" target="git">
                            <property name="dirs.root" value="${dirs.root}/../fof3" />
                            <property name="version" value="${fof.version}" />
                        </phing>

                        <!-- ...and copy it to the release directory -->
                        <copy todir="${dirs.release}" overwrite="true">
                            <mapper type="regexp" from="^(lib_fof30)(-.*)\.zip$" to="\1.zip" />
                            <fileset dir="${dirs.root}/../fof3/release">
                                <include name="lib_fof30-*.zip" />
                            </fileset>
                        </copy>
                    </then>
                    <else>
                        <!-- Get the FOF update XML file -->
                        <httpget url="https://akeeba-cdn.s3.amazonaws.com/updates/fof3.xml" dir="${dirs.release}" filename="fof.tmp" followRedirects="true" />

                        <!-- Extract the latest FOF version and download location -->
                        <xslt todir="${dirs.release}" style="${phing.dir}/tools/foflatest.xslt">
                            <mapper type="glob" from="*.tmp" to="*.xml" />
                            <fileset dir="${dirs.release}">
                                <include name="fof.tmp" />
                            </fileset>
                        </xslt>
                        <delete file="${dirs.release}/fof.tmp" />
                        <xmlproperty file="${dirs.release}/fof.xml" />
                        <echo message="Latest FOF version ${latestFof.version} - ${latestFof.download}" />

                        <!-- Make sure there is a cache directory, or create it -->
                        <if>
                            <available file="${dirs.root}/../buildfiles/cache" />
                            <else>
                                <mkdir dir="${dirs.root}/../buildfiles/cache" />
                            </else>
                        </if>

                        <!-- Get the FOF version from the cache -->
                        <property name="cache_file_exists" value="0" />
                        <available file="${dirs.root}/../buildfiles/cache/fof.xml" property="cache_file_exists" value="1" />

                        <if>
                            <equals arg1="${cache_file_exists}" arg2="1" />
                            <then>
                                <xmlproperty file="${dirs.root}/../buildfiles/cache/fof.xml" keepRoot="false" prefix="fofcache." />
                            </then>
                            <else>
                                <property name="fofcache.version" value="0.0.0" />
                                <property name="fofcache.download" value="" />
                            </else>
                        </if>

                        <echo message="${latestFof.version} - ${fofcache.version}" />

                        <!-- If there is a newer version of FOF available, download it to the cache and update the cached versions -->
                        <php expression="version_compare('${latestFof.version}','${fofcache.version}','gt') ? 1 : 0" returnProperty="has_newer_fof" />
                        <if>
                            <equals arg1="${has_newer_fof}" arg2="1" />
                            <then>
                                <httpget url="${latestFof.download}" dir="${dirs.root}/../buildfiles/cache" filename="lib_fof30.zip" followRedirects="true" />
                                <copy file="${dirs.release}/fof.xml" todir="${dirs.root}/../buildfiles/cache" />
                            </then>
                        </if>

                        <!-- Copy the cached FOF release -->
                        <copy file="${dirs.root}/../buildfiles/cache/lib_fof30.zip" todir="${dirs.release}" />

                        <!-- Clean up -->
                        <delete file="${dirs.release}/fof.xml" />
                    </else>
                </if>
            </then>
        </if>
	</target>

	<!--
	Internal task to put the correct Akeeba Strapper package in your release directory as file_strapper30.zip

	If you are building a dev release (the name contains the string dev, rev, git or svn) we'll include a dev build of
	Strapper. THIS IS NOT RECOMMENDED. It must only be used for TESTING, never on live sites!

	If you are building a regular, numeric versioned released the latest Strapper package available from akeebabackup.com
	will be included instead. THIS IS THE ONLY RECOMMENDED METHOD FOR PUBLIC RELEASES.
	-->
	<target name="package-strapper" description="Copy the Akeeba Strapper 3 installation package to the release directory">
		<if>
			<!-- Only build when the build.strapper property is true -->
			<istrue value="${build.strapper}" />
            <then>
				<if>
					<or>
						<contains string="${version}" substring="rev" />
						<contains string="${version}" substring="dev" />
						<contains string="${version}" substring="git" />
						<contains string="${version}" substring="svn" />
					</or>
					<then>
						<!-- Start by building a dev build of Strapper... -->
						<gitversion workingcopy="${dirs.root}/../strapper" propertyname="git.strapper.lastrevision" />
						<gitdate workingcopy="${dirs.root}/../strapper" propertyname="git.strapper.timestamp" />
						<property name="strapper.version" value="rev${git.strapper.lastrevision}-${git.strapper.timestamp}" override="true" />

						<phing phingfile="build.xml" dir="${dirs.root}/../strapper/build" inheritAll="false" target="git">
							<property name="dirs.root" value="${dirs.root}/../strapper" />
							<property name="version" value="${strapper.version}" />
						</phing>

						<!-- ...and copy it to the release directory -->
						<copy todir="${dirs.release}" overwrite="true">
							<mapper type="regexp" from="^(file_strapper30)(-.*)\.zip$" to="\1.zip" />
							<fileset dir="${dirs.root}/../strapper/release">
								<include name="file_strapper30-*.zip" />
							</fileset>
						</copy>
					</then>
					<else>
						<!-- Get the Strapper update XML file -->
						<httpget url="https://akeeba-cdn.s3.amazonaws.com/updates/strapper.xml" dir="${dirs.release}" filename="strapper.tmp" followRedirects="true" />

						<!-- Extract the latest Strapper version and download location -->
						<xslt todir="${dirs.release}" style="${phing.dir}/tools/strapperlatest.xslt">
							<mapper type="glob" from="*.tmp" to="*.xml" />
							<fileset dir="${dirs.release}">
								<include name="strapper.tmp" />
							</fileset>
						</xslt>
						<delete file="${dirs.release}/strapper.tmp" />
						<xmlproperty file="${dirs.release}/strapper.xml" />
						<echo message="Latest Akeeba Strapper version ${latestStrapper.version} - ${latestStrapper.download}" />

						<!-- Make sure there is a cache directory, or create it -->
						<if>
							<available file="${dirs.root}/../buildfiles/cache" />
							<else>
								<mkdir dir="${dirs.root}/../buildfiles/cache" />
							</else>
						</if>

						<!-- Get the Strapper version from the cache -->
						<property name="strapper_cache_file_exists" value="0" />
						<available file="${dirs.root}/../buildfiles/cache/strapper.xml" property="strapper_cache_file_exists" value="1" />

						<if>
							<equals arg1="${strapper_cache_file_exists}" arg2="1" />
							<then>
								<xmlproperty file="${dirs.root}/../buildfiles/cache/strapper.xml" keepRoot="false" prefix="strappercache." />
							</then>
							<else>
								<property name="strappercache.version" value="0.0.0" />
								<property name="strappercache.download" value="" />
							</else>
						</if>

						<echo message="${latestStrapper.version} - ${strappercache.version}" />

						<!-- If there is a newer version of Strapper available, download it to the cache and update the cached versions -->
						<php expression="version_compare('${latestStrapper.version}','${strappercache.version}','gt') ? 1 : 0" returnProperty="has_newer_strapper" />
						<if>
							<equals arg1="${has_newer_strapper}" arg2="1" />
							<then>
								<httpget url="${latestStrapper.download}" dir="${dirs.root}/../buildfiles/cache" filename="file_strapper30.zip" followRedirects="true" />
								<copy file="${dirs.release}/strapper.xml" todir="${dirs.root}/../buildfiles/cache" />
							</then>
						</if>

						<!-- Copy the cached Strapper release -->
						<copy file="${dirs.root}/../buildfiles/cache/file_strapper30.zip" todir="${dirs.release}" />

						<!-- Clean up -->
						<delete file="${dirs.release}/strapper.xml" />
					</else>
				</if>
			</then>
		</if>
	</target>

	<!--
	Builds all Core and Pro packages (pkg_something*.zip)
	-->
	<target name="package-pkg" description="Installation package (pkg_something)" depends="new-release, setup-properties, package-com, package-files, package-modules, package-plugins, package-fof, package-strapper">

		<!-- Build the Core package -->
		<phingcall target="package-pkg-builder">
			<property name="build.is_pro" value="0" />
		</phingcall>

		<if>
			<equals arg1="${build.has_pro}" arg2="1" />
			<then>
				<!-- Build the Pro package -->
				<phingcall target="package-pkg-builder">
					<property name="build.is_pro" value="1" />
				</phingcall>

				<!-- Clean up -->
				<delete>
					<fileset refid="package-core" />
					<fileset refid="package-pro" />
				</delete>
			</then>
			<else>
				<!-- Clean up -->
				<delete>
					<fileset refid="package" />
				</delete>
			</else>
		</if>

	</target>

	<!--
	Internal task to build one installation package (Core or Pro) at a time.
	-->
	<target name="package-pkg-builder" description="Create an installation package">

		<!-- Determine the name of the XML manifest template file, package file and the fileset reference ID -->
		<if>
			<not>
				<equals arg1="${build.has_pro}" arg2="1" />
			</not>
			<then>
				<!-- No Pro/Core version, do not use a suffix -->
				<!-- XML Manifest name: pkg_something.xml -->
				<property name="build.template_xml" value="pkg_${build.component}.xml" />
				<!-- Package name: pkg_something-1.2.3.zip -->
				<property name="build.package_name" value="pkg_${build.component}-${version}.zip" />
				<!-- Fileset reference ID: package -->
				<property name="build.refid" value="package" />
			</then>
			<else>
				<!-- Distinct Pro / Core versions, use a suffix -->
				<if>
					<equals arg1="${build.is_pro}" arg2="1" />
					<then>
						<property name="build.suffix" value="pro" />
					</then>
					<else>
						<property name="build.suffix" value="core" />
					</else>
				</if>
				<!-- XML Manifest name: pkg_something_core.xml -->
				<property name="build.template_xml" value="pkg_${build.component}_${build.suffix}.xml" />
				<!-- Package name: pkg_something-1.2.3-core.zip -->
				<property name="build.package_name" value="pkg_${build.component}-${version}-${build.suffix}.zip" />
				<!-- Fileset reference ID: package-core -->
				<property name="build.refid" value="package-${build.suffix}" />
			</else>
		</if>

		<!-- Create the XML manifest. IMPORTANT: THE TARGET NAME IS ALWAYS pkg_something.xml WITHOUT A SUFFIX TO ALLOW
		 JOOMLA! TO UPGRADE FROM CORE TO PRO WITHOUT SCREWING UP THE #__extensions ENTRIES!!! -->
		<copy file="${phing.dir}/templates/${build.template_xml}" tofile="${dirs.release}/pkg_${build.component}.xml" overwrite="true">
			<filterchain>
				<replacetokens begintoken="##" endtoken="##">
					<token key="DATE" value="${build.date}" />
					<token key="VERSION" value="${version}" />
				</replacetokens>
			</filterchain>
		</copy>

		<!-- Copy the LICENSE.txt file, if present -->
		<if>
			<available property="completely.ignored" file="${dirs.component}/LICENSE.txt" />
			<then>
				<copy file="${dirs.component}/LICENSE.txt" tofile="${dirs.release}/LICENSE.txt" overwrite="true" />
			</then>
		</if>

		<!-- Copy the script.something.php installation script file, if present -->
		<if>
			<available property="completely.ignored" file="${dirs.component}/script.${build.component}.php" />
			<then>
				<copy file="${dirs.component}/script.${build.component}.php" tofile="${dirs.release}/script.${build.component}.php" overwrite="true" />
			</then>
		</if>

		<!-- Create the ZIP file -->
		<zipme basedir="${dirs.release}" destfile="${dirs.release}/${build.package_name}" includeemptydirs="true">
			<fileset refid="${build.refid}" />
		</zipme>
	</target>

    <target name="lang">
        <echo message="The lang task is obsolete." />
    </target>
</project>